# 数据结构算法

## 最小生成树

### 生成树

兄贵，学习$MST$之前先来了解一下什么是生成树吧，概念如下

> 对于无向带权图G和一棵树T来说，如果T是G的子图，则称T为G的树，如果T是G的生成子图，则称T是G的生成树。
>
> 简而言之，生成树是一个极小连通子图，它含有图中全部顶点，但只有n-1条边。

### 最小生成树

最小生成树$(Minimum\ cost\ Spanning\ Tree)$，就是所有生成树中各边权值之和最小的那个生成树。

![image-20210405004607377](datasturcture-algorithm.assets/image-20210405004607377.png)

> **构造最小生成树的准则**
>
> - 必须只使用该网络中的边来构造最小生成树；
> - 必须使用且仅使用*n*-1条边来联结网络中的*n*个顶点；
> - 不能使用产生回路的边。

对于最小生成树，常见的生成算法有两种：$Kruskal$算法和$Prim$算法，[参考链接](https://www.bilibili.com/video/BV1Eb41177d1?from=search&seid=5353145092427265999)

### $Kruskal$算法

**定义**

此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。（贪心思想）

**具体步骤**

1. 把图中的所有边按代价从小到大排序； 

2. 把图中的$n$个顶点看成独立的$n$棵树组成的森林； 

3. 按权值从小到大选择边，所选的边连接的两个顶点$ui,vi$。$ui,vi$,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 

4. 重复3,直到所有顶点都在一颗树内或者有$n-1$条边为止。

**步骤演示**

![image-20210405004840382](datasturcture-algorithm.assets/image-20210405004840382.png)

### Prim算法

**定义**

此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点$s$开始，逐渐长大覆盖整个连通网的所有顶点。

**具体步骤**

1. 从任意一个顶点开始构造生成树，将该顶点加入生成树中，用一个一维数组selected来标记哪些顶点已经加入了生成树。

2. 用数组$minDist$记录生成树到各个顶点的距离，最初生成树中之后1号 顶点，有直连边时，数组$minDist$中存储的就是1号顶点到该顶点的边的权值，没有直连边的时候就是INF，即初始化$minDist$数组。

3. 从数组$minDist$中选出离生成树最近的顶点（假设这个顶点为j）加入到生成树中（即在数组$minDist$中找到最小值）。再以j为中间点，更新生成树到每一个非树顶点的距离（松弛）， 即如果$minDist[k]>e[j][k]$则更新$minDist[k]=e[j][k]$。

4. 重复第三步，直到生成树中有n个顶点为止。

**步骤演示**

![image-20210106094949412](datasturcture-algorithm.assets/image-20210106094949412.png)

### 两种算法的比较

**从策略上来说**

Prim算法是直接查找，多次寻找邻边的权重最小值

Kruskal是需要先对权重排序后查找的

**从时间复杂度分析**

prim: 该算法的时间复杂度为$O(n2)$。 与图中边数无关，该算法适合于**稠密图**

kruskal: 时间复杂度为$O(eloge)$。 适合**稀疏图**

**所以说**

Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树；而Prim算法需要多次对邻边排序才能找到

## 并查集

### 定义

> 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。

### 应用情境

- 由于最小生成树需要维护连通性，并查集刚好可以做到通过构建树来判断元素之间的连通性、查找出两个元素是否位于同一元素。所以并查集在$MST$的建立过程中有着很大的作用
- 集合操作

### 操作

PPOO...

## 拓扑排序

### AOE网

### AOV网

## 最短路

### Dijkstra算法

### Floyd算法

## 强连通分量

### Tarjon算法

### Kosaraju算法

### Gabow算法